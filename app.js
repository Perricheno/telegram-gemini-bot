// app.js

// Загружаем переменные окружения из .env файла, если он существует.
// Это полезно для локальной разработки. На Render переменные окружения
// будут предоставлены хостингом напрямую.
// Эта строка должна быть самой первой в файле.
require('dotenv').config();

// Импортируем необходимые библиотеки
const { Telegraf } = require('telegraf');
const express = require('express');
// const path = require('path'); // path не используется в этом простом примере, но может пригодиться

// 1. Получаем токен бота из переменной окружения
// process.env содержит переменные окружения системы и те, что загружены dotenv.config().
const token = process.env.TELEGRAM_BOT_TOKEN;

// 2. Проверяем, был ли токен успешно загружен.
// Без токена бот не сможет подключиться к Telegram API.
if (!token) {
    console.error('Ошибка: Переменная окружения TELEGRAM_BOT_TOKEN не установлена.');
    console.error('Пожалуйста, установите TELEGRAM_BOT_TOKEN в переменных окружения Render или в локальном файле .env');
    // Завершаем выполнение программы с кодом ошибки.
    process.exit(1);
}

// 3. Инициализируем экземпляр бота Telegraf с полученным токеном.
const bot = new Telegraf(token);

// 4. Определяем обработчик для всех входящих текстовых сообщений.
// bot.on('text', ...) регистрирует функцию, которая будет вызвана
// для каждого сообщения, тип которого 'text'.
// Используем async, хотя для ctx.reply в данном случае await не строго обязателен,
// но это хорошая практика для асинхронных операций.
bot.on('text', async (ctx) => {
  // Логируем полученное сообщение (полезно для отладки на Render через логи).
  console.log(`Получено сообщение от ${ctx.from.first_name || ctx.from.username}: ${ctx.message.text}`);

  // Отправляем обратно тот же текст сообщения, который был получен.
  try {
    await ctx.reply(ctx.message.text);
    console.log(`Отправлен ответ: ${ctx.message.text}`);
  } catch (error) {
    // Логируем ошибки, если что-то пошло не так при отправке.
    console.error('Ошибка при отправке ответа:', error);
  }
});

// Опционально: Можно добавить обработчики для команд или других типов сообщений.
// Например, обработчик команды /start:
// bot.start((ctx) => ctx.reply('Привет! Я простой Эхо бот. Напиши мне что-нибудь, и я повторю.'));

// ------------------------------------------------------------
// 5. Настройка веб-сервера Express для обработки вебхуков от Telegram.
// Telegraf в режиме вебхуков требует наличия веб-сервера, который
// будет принимать POST запросы от Telegram и передавать их боту.
// ------------------------------------------------------------

// Инициализируем приложение Express.
const app = express();

// Определяем порт, на котором веб-сервер будет слушать запросы.
// Render предоставляет порт через переменную окружения PORT.
// Локально, если PORT не установлен, будет использоваться порт 3000.
const port = process.env.PORT || 3000;

// Middleware для парсинга входящих JSON тел запросов.
// Telegram отправляет обновления через вебхуки в формате JSON.
app.use(express.json());

// Определяем маршрут '/webhook', на который Telegram будет отправлять POST запросы с обновлениями.
// Этот маршрут будет принимать данные и передавать их в Telegraf для обработки.
app.post('/webhook', (req, res) => {
    // bot.handleUpdate(req.body) принимает тело запроса (JSON с обновлением)
    // и передает его в Telegraf для обработки зарегистрированными обработчиками (bot.on, bot.command и т.д.).
    bot.handleUpdate(req.body);
    // Отправляем HTTP статус 200 OK в ответ на запрос Telegram,
    // чтобы подтвердить, что обновление было получено и обрабатывается.
    res.sendStatus(200);
});

// Опционально: Добавляем простой корневой эндпоинт '/' для проверки статуса сервера.
// При переходе по главному URL задеплоенного сервиса на Render можно будет увидеть это сообщение.
app.get('/', (req, res) => {
  res.send('Telegram Echo Bot server is running and waiting for webhooks at /webhook.');
});

// ------------------------------------------------------------
// 6. Запуск веб-сервера Express.
// ------------------------------------------------------------

// Запускаем сервер на определенном порту.
app.listen(port, () => {
  console.log(`Сервер запущен на порту ${port}`);
  console.log(`Эндпоинт для вебхуков настроен по пути: /webhook`);
  // Логируем, был ли токен успешно загружен.
  console.log(`Токен бота загружен: ${token ? 'Да' : 'Нет'}`);
  console.log('Ожидание входящих вебхуков от Telegram...');

  // При локальном запуске, тебе нужно будет вручную установить вебхук
  // (например, используя ngrok для получения публичного URL).
  // При деплое на Render, вебхук устанавливается один раз с публичным URL Render
  // запросом к Telegram Bot API.
});

// ВАЖНОЕ ПРИМЕЧАНИЕ:
// При использовании вебхуков, мы запускаем ТОЛЬКО веб-сервер (app.listen).
// Мы НЕ вызываем bot.launch(), который используется для режима long polling.
// Telegraf получает обновления через middleware Express и вызов bot.handleUpdate().