// app.js

// 1. В САМОЕ НАЧАЛО ФАЙЛА ДОБАВЛЯЕМ ЗАГРУЗКУ ПЕРЕМЕННЫХ ОКРУЖЕНИЯ ИЗ .env ФАЙЛА
// Эта строка должна быть первой, чтобы переменные были доступны до их использования.
require('dotenv').config();

// 2. Импортируем необходимые библиотеки
const { Telegraf } = require('telegraf');
const express = require('express');
const path = require('path'); // Импортируем path, хотя в этом простом примере он не используется, но может пригодиться в будущем.

// 3. Получаем токен бота из переменной окружения
// process.env содержит переменные окружения системы,
// а также переменные, загруженные из .env файла благодаря dotenv.config()
const token = process.env.TELEGRAM_BOT_TOKEN;

// 4. Проверяем, был ли токен успешно загружен
if (!token) {
    console.error('Ошибка: Переменная окружения TELEGRAM_BOT_TOKEN не установлена.');
    // Завершаем процесс, если токен не найден.
    // Это важно, потому что без токена бот работать не сможет.
    process.exit(1);
}

// 5. Инициализируем экземпляр бота Telegraf
const bot = new Telegraf(token);

// 6. Определяем обработчик для входящих текстовых сообщений
// bot.on('text', ...) регистрирует функцию, которая будет вызвана каждый раз,
// когда бот получает сообщение типа 'text'.
bot.on('text', (ctx) => {
  // ctx (context) - это объект, содержащий всю информацию о входящем обновлении (сообщении, команде и т.д.)
  // ctx.message.text - это непосредственно текст сообщения, которое отправил пользователь.
  // ctx.reply() - это удобный метод для отправки ответа в тот же чат, откуда пришло сообщение.
  ctx.reply(ctx.message.text);
});

// Опционально: можно добавить обработчики для других типов сообщений или команд
// bot.start((ctx) => ctx.reply('Привет! Я Эхо бот. Просто напиши мне что-нибудь.'));
// bot.command('help', (ctx) => ctx.reply('Я просто повторяю все, что ты мне пишешь.'));

// ------------------------------------------------------------
// 7. Настройка веб-сервера Express для обработки вебхуков от Telegram
// ------------------------------------------------------------

// Инициализируем приложение Express
const app = express();

// Определяем порт, на котором будет работать веб-сервер.
// Render предоставит порт через переменную окружения PORT.
// Локально, если PORT не установлен, будет использоваться 3000.
const port = process.env.PORT || 3000;

// Middleware для парсинга входящих JSON запросов.
// Telegram отправляет обновления через вебхуки в формате JSON.
app.use(express.json());

// Определяем маршрут '/webhook', на который Telegram будет отправлять обновления.
// bot.webhookCallback('/webhook') создает middleware, которое:
// а) Проверяет, что запрос пришел именно на этот путь.
// б) Парсит тело POST запроса как JSON.
// в) Преобразует JSON в объект Telegraf Update.
// г) Передает объект Update в Telegraf для обработки зарегистрированными bot.on(), bot.command() и т.д. обработчиками.
app.use(bot.webhookCallback('/webhook'));

// Опционально: добавляем простой эндпоинт '/' для проверки статуса сервера
// При переходе по корневому URL задеплоенного сервиса Render, можно будет увидеть это сообщение.
app.get('/', (req, res) => {
  res.send('Hello World! Bot server is running and waiting for webhooks.');
});

// 8. Запускаем веб-сервер Express
app.listen(port, () => {
  console.log(`Server running on port ${port}`);
  console.log(`Webhook endpoint configured at /webhook`);
  console.log(`Telegram Bot Token loaded: ${token ? 'Yes' : 'No'}`); // Проверяем, загружен ли токен
  // При локальном запуске, тебе нужно будет вручную установить вебхук
  // командой или через браузер с использованием ngrok или подобного.
  // При деплое на Render, вебхук устанавливается один раз с публичным URL Render.
});

// Примечание: В режиме вебхуков мы запускаем ТОЛЬКО веб-сервер Express (app.listen).
// Мы НЕ вызываем bot.launch(), который используется для режима long polling.
// Telegraf получает обновления через middleware bot.webhookCallback().